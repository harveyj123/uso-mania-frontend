{"version":3,"file":"canvas-graphics.min.js","sources":["../../src/Graphics.ts","../../src/utils/PolygonUtils.ts","../../src/CanvasGraphicsRenderer.ts"],"sourcesContent":["import { Graphics } from '@pixi/graphics';\nimport { CanvasRenderer } from '@pixi/canvas-renderer';\nimport { RenderTexture, Texture } from '@pixi/core';\nimport { Matrix } from '@pixi/math';\n\nimport type { SCALE_MODES } from '@pixi/constants';\nimport type { BaseRenderTexture } from '@pixi/core';\n\nlet canvasRenderer: CanvasRenderer;\nconst tempMatrix = new Matrix();\n\n/**\n * Generates a canvas texture. Only available with **pixi.js-legacy** bundle\n * or the **@pixi/canvas-graphics** package.\n * @method generateCanvasTexture\n * @memberof PIXI.Graphics#\n * @param {PIXI.SCALE_MODES} scaleMode - The scale mode of the texture.\n * @param {number} resolution - The resolution of the texture.\n * @return {PIXI.Texture} The new texture.\n */\nGraphics.prototype.generateCanvasTexture = function generateCanvasTexture(scaleMode: SCALE_MODES, resolution = 1): Texture\n{\n    const bounds = this.getLocalBounds();\n\n    const canvasBuffer = RenderTexture.create({\n        width: bounds.width,\n        height: bounds.height,\n        scaleMode,\n        resolution,\n    });\n\n    if (!canvasRenderer)\n    {\n        canvasRenderer = new CanvasRenderer();\n    }\n\n    this.transform.updateLocalTransform();\n    this.transform.localTransform.copyTo(tempMatrix);\n\n    tempMatrix.invert();\n\n    tempMatrix.tx -= bounds.x;\n    tempMatrix.ty -= bounds.y;\n\n    canvasRenderer.render(this, { renderTexture: canvasBuffer, clear: true, transform: tempMatrix });\n\n    const texture = Texture.from((canvasBuffer.baseTexture as BaseRenderTexture)._canvasRenderTarget.canvas, {\n        scaleMode,\n    });\n\n    texture.baseTexture.setResolution(resolution);\n\n    return texture;\n};\n\nGraphics.prototype.cachedGraphicsData = [];\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @method _renderCanvas\n * @memberof PIXI.Graphics#\n * @private\n * @param {PIXI.CanvasRenderer} renderer - The renderer\n */\nGraphics.prototype._renderCanvas = function _renderCanvas(renderer: CanvasRenderer): void\n{\n    if (this.isMask === true)\n    {\n        return;\n    }\n\n    this.finishPoly();\n    renderer.plugins.graphics.render(this);\n};\n","/**\n * Utilities for polygon\n * @class\n * @private\n */\nexport class PolygonUtils\n{\n    /**\n    * Calculate points of an offset polygon\n    * @see {@link http://csharphelper.com/blog/2016/01/enlarge-a-polygon-in-c/}\n    *\n    * @private\n    * @param {number[]} points - polygon coordinates\n    * @param {number} offset\n    * @return {number[]} - offset points\n    */\n    static offsetPolygon(points: number[], offset: number): number[]\n    {\n        const offsetPoints: number[] = [];\n        const length: number = points.length;\n\n        offset = PolygonUtils.isPolygonClockwise(points) ? offset : -1 * offset;\n\n        for (let j = 0; j < length; j += 2)\n        {\n            // Find location for the points before and after j\n            let i = (j - 2);\n\n            if (i < 0)\n            {\n                i += length;\n            }\n\n            const k = (j + 2) % length;\n\n            // Move the points by the offset\n            let v1x = points[j] - points[i];\n            let v1y = points[j + 1] - points[i + 1];\n            let len = Math.sqrt((v1x * v1x) + (v1y * v1y));\n\n            v1x /= len;\n            v1y /= len;\n            v1x *= offset;\n            v1y *= offset;\n\n            const norm1x = -v1y;\n            const norm1y = v1x;\n\n            const pij1 = [points[i] + norm1x, points[i + 1] + norm1y];\n            const pij2 = [points[j] + norm1x, points[j + 1] + norm1y];\n\n            let v2x = points[k] - points[j];\n            let v2y = points[k + 1] - points[j + 1];\n\n            len = Math.sqrt((v2x * v2x) + (v2y * v2y));\n\n            v2x /= len;\n            v2y /= len;\n            v2x *= offset;\n            v2y *= offset;\n\n            const norm2x = -v2y;\n            const norm2y = v2x;\n\n            const pjk1 = [points[j] + norm2x, points[j + 1] + norm2y];\n            const pjk2 = [points[k] + norm2x, points[k + 1] + norm2y];\n\n            // Find where the shifted lines ij and jk intersect.\n            const intersectPoint = PolygonUtils\n                .findIntersection(pij1[0], pij1[1], pij2[0], pij2[1], pjk1[0], pjk1[1], pjk2[0], pjk2[1]);\n\n            if (intersectPoint)\n            {\n                offsetPoints.push(...intersectPoint);\n            }\n        }\n\n        return offsetPoints;\n    }\n\n    /**\n    * Determine the intersection point of two line segments\n    * @see {@link here http://paulbourke.net/geometry/pointlineplane/}\n    *\n    * @private\n    * @param {number} x1 - x-coordinate of start point at first line\n    * @param {number} y1 - y-coordinate of start point at first line\n    * @param {number} x2 - x-coordinate of end point at first line\n    * @param {number} y2 - y-coordinate of end point at first line\n    * @param {number} x3 - x-coordinate of start point at second line\n    * @param {number} y3 - y-coordinate of start point at second line\n    * @param {number} x4 - x-coordinate of end point at second line\n    * @param {number} y4 - y-coordinate of end point at second line\n    * @returns {[number, number] | null} - [x, y] coordinates of intersection\n    */\n    static findIntersection(\n        x1: number, y1: number, x2: number, y2: number,\n        x3: number, y3: number, x4: number, y4: number\n    ): [number, number] | null\n    {\n        const denominator = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));\n        const numeratorA = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));\n        const numeratorB = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));\n\n        // lines are parallel\n        if (denominator === 0)\n        {\n            // lines are coincident\n            if (numeratorA === 0 && numeratorB === 0)\n            {\n                return [(x1 + x2) / 2, (y1 + y2) / 2];\n            }\n\n            return null;\n        }\n\n        const uA = numeratorA / denominator;\n\n        return [x1 + (uA * (x2 - x1)), y1 + (uA * (y2 - y1))];\n    }\n\n    /**\n     * Determine polygon are clockwise or counterclockwise\n     * @see {@link https://stackoverflow.com/questions/1165647}\n     *\n     * @private\n     * @param {number[]} polygon - polygon coordinates\n     * @return {boolean}\n     */\n    static isPolygonClockwise(polygon: number[]): boolean\n    {\n        let sum = 0;\n\n        for (let i = 0, j = polygon.length - 2; i < polygon.length; j = i, i += 2)\n        {\n            sum += (polygon[i] - polygon[j]) * (polygon[i + 1] + polygon[j + 1]);\n        }\n\n        return sum > 0;\n    }\n}\n","import { Texture } from '@pixi/core';\nimport { SHAPES, Matrix } from '@pixi/math';\nimport { canvasUtils, CrossPlatformCanvasRenderingContext2D } from '@pixi/canvas-renderer';\nimport type { CanvasRenderer } from '@pixi/canvas-renderer';\nimport type { FillStyle, Graphics, GraphicsData, LineStyle } from '@pixi/graphics';\nimport type { Circle, Ellipse, Polygon, Rectangle, RoundedRectangle } from '@pixi/math';\nimport { PolygonUtils } from './utils/PolygonUtils';\n\n/*\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they\n * now share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's CanvasGraphicsRenderer:\n * https://github.com/libgdx/libgdx/blob/1.0.0/gdx/src/com/badlogic/gdx/graphics/glutils/ShapeRenderer.java\n */\n\n/**\n * Renderer dedicated to drawing and batching graphics objects.\n *\n * @class\n * @protected\n * @memberof PIXI\n */\nexport class CanvasGraphicsRenderer\n{\n    /** A reference to the current renderer */\n    public renderer: CanvasRenderer;\n    private _svgMatrix: DOMMatrix|boolean = null;\n    private _tempMatrix: Matrix = new Matrix();\n\n    /**\n     * @param renderer - A reference to the current renderer.\n     */\n    constructor(renderer: CanvasRenderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * calculates fill/stroke style for canvas\n     *\n     * @private\n     * @param style - A graphics {@link PIXI.FILL_STYLE} where if `texture` is specified then a tinted CanvasPattern\n     * will be used for the fill.stroke\n     * @param tint - color to set the fill/stroke too.\n     */\n    private _calcCanvasStyle(style: FillStyle, tint: number): string|CanvasPattern\n    {\n        let res;\n\n        if (style.texture && style.texture.baseTexture !== Texture.WHITE.baseTexture)\n        {\n            if (style.texture.valid)\n            {\n                res = canvasUtils.getTintedPattern(style.texture, tint);\n                this.setPatternTransform(res, style.matrix || Matrix.IDENTITY);\n            }\n            else\n            {\n                res = '#808080';\n            }\n        }\n        else\n        {\n            res = `#${(`00000${(tint | 0).toString(16)}`).slice(-6)}`;\n        }\n\n        return res;\n    }\n\n    /**\n     * Renders a Graphics object to a canvas.\n     *\n     * @param graphics - the actual graphics object to render\n     */\n    public render(graphics: Graphics): void\n    {\n        const renderer = this.renderer;\n        const context = renderer.context;\n        const worldAlpha = graphics.worldAlpha;\n        const transform = graphics.transform.worldTransform;\n\n        renderer.setContextTransform(transform);\n        renderer.setBlendMode(graphics.blendMode);\n\n        const graphicsData = graphics.geometry.graphicsData;\n\n        let contextFillStyle;\n        let contextStrokeStyle;\n\n        const tintR = ((graphics.tint >> 16) & 0xFF) / 255;\n        const tintG = ((graphics.tint >> 8) & 0xFF) / 255;\n        const tintB = (graphics.tint & 0xFF) / 255;\n\n        for (let i = 0; i < graphicsData.length; i++)\n        {\n            const data = graphicsData[i];\n            const shape = data.shape;\n            const fillStyle = data.fillStyle;\n            const lineStyle = data.lineStyle;\n\n            const fillColor = data.fillStyle.color | 0;\n            const lineColor = data.lineStyle.color | 0;\n\n            if (data.matrix)\n            {\n                renderer.setContextTransform(transform.copyTo(this._tempMatrix).append(data.matrix));\n            }\n\n            if (fillStyle.visible)\n            {\n                const fillTint = (\n                    (((fillColor >> 16) & 0xFF) / 255 * tintR * 255 << 16)\n                    + (((fillColor >> 8) & 0xFF) / 255 * tintG * 255 << 8)\n                    + (((fillColor & 0xFF) / 255) * tintB * 255)\n                );\n\n                contextFillStyle = this._calcCanvasStyle(fillStyle, fillTint);\n            }\n            if (lineStyle.visible)\n            {\n                const lineTint = (\n                    (((lineColor >> 16) & 0xFF) / 255 * tintR * 255 << 16)\n                    + (((lineColor >> 8) & 0xFF) / 255 * tintG * 255 << 8)\n                    + (((lineColor & 0xFF) / 255) * tintB * 255)\n                );\n\n                contextStrokeStyle = this._calcCanvasStyle(lineStyle, lineTint);\n            }\n\n            context.lineWidth = lineStyle.width;\n            context.lineCap = lineStyle.cap;\n            context.lineJoin = lineStyle.join;\n            context.miterLimit = lineStyle.miterLimit;\n\n            if (data.type === SHAPES.POLY)\n            {\n                context.beginPath();\n\n                const tempShape = shape as Polygon;\n                let points = tempShape.points;\n                const holes = data.holes;\n                let outerArea;\n                let innerArea;\n                let px;\n                let py;\n                let holesDirection: boolean[];\n\n                context.moveTo(points[0], points[1]);\n\n                for (let j = 2; j < points.length; j += 2)\n                {\n                    context.lineTo(points[j], points[j + 1]);\n                }\n\n                if (tempShape.closeStroke)\n                {\n                    context.closePath();\n                }\n\n                if (holes.length > 0)\n                {\n                    holesDirection = [];\n                    outerArea = 0;\n                    px = points[0];\n                    py = points[1];\n                    for (let j = 2; j + 2 < points.length; j += 2)\n                    {\n                        outerArea += ((points[j] - px) * (points[j + 3] - py))\n                            - ((points[j + 2] - px) * (points[j + 1] - py));\n                    }\n\n                    for (let k = 0; k < holes.length; k++)\n                    {\n                        points = (holes[k].shape as Polygon).points;\n\n                        if (!points)\n                        {\n                            continue;\n                        }\n\n                        innerArea = 0;\n                        px = points[0];\n                        py = points[1];\n                        for (let j = 2; j + 2 < points.length; j += 2)\n                        {\n                            innerArea += ((points[j] - px) * (points[j + 3] - py))\n                                - ((points[j + 2] - px) * (points[j + 1] - py));\n                        }\n\n                        if (innerArea * outerArea < 0)\n                        {\n                            context.moveTo(points[0], points[1]);\n\n                            for (let j = 2; j < points.length; j += 2)\n                            {\n                                context.lineTo(points[j], points[j + 1]);\n                            }\n                        }\n                        else\n                        {\n                            context.moveTo(points[points.length - 2], points[points.length - 1]);\n\n                            for (let j = points.length - 4; j >= 0; j -= 2)\n                            {\n                                context.lineTo(points[j], points[j + 1]);\n                            }\n                        }\n\n                        if ((holes[k].shape as Polygon).closeStroke)\n                        {\n                            context.closePath();\n                        }\n\n                        holesDirection[k] = innerArea * outerArea < 0;\n                    }\n                }\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = contextFillStyle;\n                    context.fill();\n                }\n\n                if (lineStyle.visible)\n                {\n                    this.paintPolygonStroke(\n                        tempShape, lineStyle, contextStrokeStyle, holes, holesDirection, worldAlpha, context\n                    );\n                }\n            }\n            else if (data.type === SHAPES.RECT)\n            {\n                const tempShape = shape as Rectangle;\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = contextFillStyle;\n                    context.fillRect(tempShape.x, tempShape.y, tempShape.width, tempShape.height);\n                }\n\n                if (lineStyle.visible)\n                {\n                    const alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));\n                    const width = tempShape.width + (2 * alignmentOffset);\n                    const height = tempShape.height + (2 * alignmentOffset);\n\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = contextStrokeStyle;\n                    context.strokeRect(tempShape.x - alignmentOffset, tempShape.y - alignmentOffset, width, height);\n                }\n            }\n            else if (data.type === SHAPES.CIRC)\n            {\n                const tempShape = shape as Circle;\n\n                // TODO - need to be Undefined!\n                context.beginPath();\n                context.arc(tempShape.x, tempShape.y, tempShape.radius, 0, 2 * Math.PI);\n                context.closePath();\n\n                if (fillStyle.visible)\n                {\n                    context.globalAlpha = fillStyle.alpha * worldAlpha;\n                    context.fillStyle = contextFillStyle;\n                    context.fill();\n                }\n\n                if (lineStyle.visible)\n                {\n                    if (lineStyle.alignment !== 0.5)\n                    {\n                        const alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));\n\n                        context.beginPath();\n                        context.arc(tempShape.x, tempShape.y, tempShape.radius + alignmentOffset, 0, 2 * Math.PI);\n                        context.closePath();\n                    }\n\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = contextStrokeStyle;\n                    context.stroke();\n                }\n            }\n            else if (data.type === SHAPES.ELIP)\n            {\n                const tempShape = shape as Ellipse;\n                const drawShapeOverStroke = lineStyle.alignment === 1;\n\n                if (!drawShapeOverStroke)\n                {\n                    this.paintEllipse(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);\n                }\n\n                if (lineStyle.visible)\n                {\n                    if (lineStyle.alignment !== 0.5)\n                    {\n                        const kappa = 0.5522848;\n                        const alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));\n                        const sW = (tempShape.width + alignmentOffset) * 2;\n                        const sH = (tempShape.height + alignmentOffset) * 2;\n                        const sX = tempShape.x - (sW / 2);\n                        const sY = tempShape.y - (sH / 2);\n                        const sOx = (sW / 2) * kappa;\n                        const sOy = (sH / 2) * kappa;\n                        const sXe = sX + sW;\n                        const sYe = sY + sH;\n                        const sXm = sX + (sW / 2);\n                        const sYm = sY + (sH / 2);\n\n                        context.beginPath();\n                        context.moveTo(sX, sYm);\n                        context.bezierCurveTo(sX, sYm - sOy, sXm - sOx, sY, sXm, sY);\n                        context.bezierCurveTo(sXm + sOx, sY, sXe, sYm - sOy, sXe, sYm);\n                        context.bezierCurveTo(sXe, sYm + sOy, sXm + sOx, sYe, sXm, sYe);\n                        context.bezierCurveTo(sXm - sOx, sYe, sX, sYm + sOy, sX, sYm);\n                        context.closePath();\n                    }\n\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = contextStrokeStyle;\n                    context.stroke();\n                }\n\n                if (drawShapeOverStroke)\n                {\n                    this.paintEllipse(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);\n                }\n            }\n            else if (data.type === SHAPES.RREC)\n            {\n                const tempShape = shape as RoundedRectangle;\n                const drawShapeOverStroke = lineStyle.alignment === 1;\n\n                if (!drawShapeOverStroke)\n                {\n                    this.paintRoundedRectangle(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);\n                }\n\n                if (lineStyle.visible)\n                {\n                    if (lineStyle.alignment !== 0.5)\n                    {\n                        const width = tempShape.width;\n                        const height = tempShape.height;\n                        const alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));\n                        const sRx = tempShape.x - alignmentOffset;\n                        const sRy = tempShape.y - alignmentOffset;\n                        const sWidth = tempShape.width + (2 * alignmentOffset);\n                        const sHeight = tempShape.height + (2 * alignmentOffset);\n                        const radiusOffset = alignmentOffset * (lineStyle.alignment >= 1\n                            ? Math.min(sWidth / width, sHeight / height) : Math.min(width / sWidth, height / sHeight));\n                        let sRadius = tempShape.radius + radiusOffset;\n                        const sMaxRadius = Math.min(sWidth, sHeight) / 2;\n\n                        sRadius = sRadius > sMaxRadius ? sMaxRadius : sRadius;\n\n                        context.beginPath();\n                        context.moveTo(sRx, sRy + sRadius);\n                        context.lineTo(sRx, sRy + sHeight - sRadius);\n                        context.quadraticCurveTo(sRx, sRy + sHeight, sRx + sRadius, sRy + sHeight);\n                        context.lineTo(sRx + sWidth - sRadius, sRy + sHeight);\n                        context.quadraticCurveTo(sRx + sWidth, sRy + sHeight, sRx + sWidth, sRy + sHeight - sRadius);\n                        context.lineTo(sRx + sWidth, sRy + sRadius);\n                        context.quadraticCurveTo(sRx + sWidth, sRy, sRx + sWidth - sRadius, sRy);\n                        context.lineTo(sRx + sRadius, sRy);\n                        context.quadraticCurveTo(sRx, sRy, sRx, sRy + sRadius);\n                        context.closePath();\n                    }\n\n                    context.globalAlpha = lineStyle.alpha * worldAlpha;\n                    context.strokeStyle = contextStrokeStyle;\n                    context.stroke();\n                }\n\n                if (drawShapeOverStroke)\n                {\n                    this.paintRoundedRectangle(tempShape, fillStyle, lineStyle, contextFillStyle, worldAlpha, context);\n                }\n            }\n        }\n    }\n\n    /**\n     * Paint stroke for polygon and holes\n     *\n     * @private\n     * @param shape - Shape to be drawn\n     * @param lineStyle - Line style for the shape\n     * @param contextStrokeStyle - The strokeStyle for the canvas context\n     * @param holes - Holes to be added to the shape\n     * @param holesDirection -\n     * @param worldAlpha - The multiplied alpha of the displayObject\n     * @param context - The canvas context\n     */\n    private paintPolygonStroke(\n        shape: Polygon, lineStyle: LineStyle, contextStrokeStyle: string|CanvasPattern,\n        holes: GraphicsData[], holesDirection: boolean[],\n        worldAlpha: number, context: CrossPlatformCanvasRenderingContext2D\n    ): void\n    {\n        if (lineStyle.alignment !== 0.5)\n        {\n            const alignmentOffset = lineStyle.width * (0.5 - (1 - lineStyle.alignment));\n            let offsetPoints = PolygonUtils.offsetPolygon(shape.points, alignmentOffset);\n            let points;\n\n            context.beginPath();\n            context.moveTo(offsetPoints[0], offsetPoints[1]);\n\n            for (let j = 2; j < offsetPoints.length; j += 2)\n            {\n                context.lineTo(offsetPoints[j], offsetPoints[j + 1]);\n            }\n\n            if (shape.closeStroke)\n            {\n                context.closePath();\n            }\n\n            for (let k = 0; k < holes.length; k++)\n            {\n                points = (holes[k].shape as Polygon).points;\n                offsetPoints = PolygonUtils.offsetPolygon(points, alignmentOffset);\n\n                if (holesDirection[k])\n                {\n                    context.moveTo(offsetPoints[0], offsetPoints[1]);\n\n                    for (let j = 2; j < offsetPoints.length; j += 2)\n                    {\n                        context.lineTo(offsetPoints[j], offsetPoints[j + 1]);\n                    }\n                }\n                else\n                {\n                    context.moveTo(offsetPoints[offsetPoints.length - 2], offsetPoints[offsetPoints.length - 1]);\n\n                    for (let j = offsetPoints.length - 4; j >= 0; j -= 2)\n                    {\n                        context.lineTo(offsetPoints[j], offsetPoints[j + 1]);\n                    }\n                }\n\n                if ((holes[k].shape as Polygon).closeStroke)\n                {\n                    context.closePath();\n                }\n            }\n        }\n\n        context.globalAlpha = lineStyle.alpha * worldAlpha;\n        context.strokeStyle = contextStrokeStyle;\n        context.stroke();\n    }\n\n    /**\n     * Paint Ellipse\n     *\n     * @private\n     * @param shape - Shape to be drawn\n     * @param fillStyle - Fill for the shape\n     * @param lineStyle - Line style for the shape\n     * @param contextFillStyle - The canvas context fill style\n     * @param worldAlpha - The multiplied alpha of the displayObject\n     * @param context - The canvas context\n     */\n    private paintEllipse(\n        shape: Ellipse, fillStyle: FillStyle, lineStyle: LineStyle,\n        contextFillStyle: string|CanvasPattern, worldAlpha: number,\n        context: CrossPlatformCanvasRenderingContext2D): void\n    {\n        // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n        const w = shape.width * 2;\n        const h = shape.height * 2;\n\n        const x = shape.x - (w / 2);\n        const y = shape.y - (h / 2);\n\n        const kappa = 0.5522848;\n        const ox = (w / 2) * kappa; // control point offset horizontal\n        const oy = (h / 2) * kappa; // control point offset vertical\n        const xe = x + w; // x-end\n        const ye = y + h; // y-end\n        const xm = x + (w / 2); // x-middle\n        const ym = y + (h / 2); // y-middle\n\n        if (lineStyle.alignment === 0)\n        {\n            context.save();\n        }\n\n        context.beginPath();\n        context.moveTo(x, ym);\n        context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n        context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n        context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n        context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n        context.closePath();\n\n        if (lineStyle.alignment === 0)\n        {\n            context.clip();\n        }\n\n        if (fillStyle.visible)\n        {\n            context.globalAlpha = fillStyle.alpha * worldAlpha;\n            context.fillStyle = contextFillStyle;\n            context.fill();\n        }\n\n        if (lineStyle.alignment === 0)\n        {\n            context.restore();\n        }\n    }\n\n    /**\n     * Paint Rounded Rectangle\n     *\n     * @private\n     * @param shape - Shape to be drawn\n     * @param fillStyle - Fill for the shape\n     * @param lineStyle - Line style for the shape\n     * @param contextFillStyle - The canvas context fill style\n     * @param worldAlpha - The multiplied alpha of the displayObject\n     * @param context - The canvas context\n     */\n    private paintRoundedRectangle(\n        shape: RoundedRectangle, fillStyle: FillStyle, lineStyle: LineStyle,\n        contextFillStyle: string|CanvasPattern, worldAlpha: number,\n        context: CrossPlatformCanvasRenderingContext2D\n    ): void\n    {\n        const rx = shape.x;\n        const ry = shape.y;\n        const width = shape.width;\n        const height = shape.height;\n        let radius = shape.radius;\n\n        const maxRadius = Math.min(width, height) / 2;\n\n        radius = radius > maxRadius ? maxRadius : radius;\n\n        if (lineStyle.alignment === 0)\n        {\n            context.save();\n        }\n\n        context.beginPath();\n        context.moveTo(rx, ry + radius);\n        context.lineTo(rx, ry + height - radius);\n        context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);\n        context.lineTo(rx + width - radius, ry + height);\n        context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);\n        context.lineTo(rx + width, ry + radius);\n        context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);\n        context.lineTo(rx + radius, ry);\n        context.quadraticCurveTo(rx, ry, rx, ry + radius);\n        context.closePath();\n\n        if (lineStyle.alignment === 0)\n        {\n            context.clip();\n        }\n\n        if (fillStyle.visible)\n        {\n            context.globalAlpha = fillStyle.alpha * worldAlpha;\n            context.fillStyle = contextFillStyle;\n            context.fill();\n        }\n\n        if (lineStyle.alignment === 0)\n        {\n            context.restore();\n        }\n    }\n\n    public setPatternTransform(pattern: CanvasPattern, matrix: Matrix): void\n    {\n        if (this._svgMatrix === false)\n        {\n            return;\n        }\n        if (!this._svgMatrix)\n        {\n            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n\n            if (svg && svg.createSVGMatrix)\n            {\n                this._svgMatrix = svg.createSVGMatrix();\n            }\n            if (!this._svgMatrix || !pattern.setTransform)\n            {\n                this._svgMatrix = false;\n\n                return;\n            }\n        }\n\n        (this._svgMatrix as DOMMatrix).a = matrix.a;\n        (this._svgMatrix as DOMMatrix).b = matrix.b;\n        (this._svgMatrix as DOMMatrix).c = matrix.c;\n        (this._svgMatrix as DOMMatrix).d = matrix.d;\n        (this._svgMatrix as DOMMatrix).e = matrix.tx;\n        (this._svgMatrix as DOMMatrix).f = matrix.ty;\n        pattern.setTransform((this._svgMatrix as DOMMatrix).inverse());\n    }\n\n    /** destroy graphics object */\n    public destroy(): void\n    {\n        this.renderer = null;\n        this._svgMatrix = null;\n        this._tempMatrix = null;\n    }\n}\n"],"names":["canvasRenderer","PolygonUtils","offsetPolygon","points","offset","offsetPoints","length","isPolygonClockwise","j","i","k","v1x","v1y","len","Math","sqrt","norm1x","norm1y","pij1","pij2","v2x","v2y","norm2x","norm2y","pjk1","pjk2","intersectPoint","findIntersection","push","apply","x1","y1","x2","y2","x3","y3","x4","y4","denominator","numeratorA","uA","polygon","sum","CanvasGraphicsRenderer","renderer","this","_svgMatrix","_tempMatrix","Matrix","prototype","_calcCanvasStyle","style","tint","res","texture","baseTexture","Texture","WHITE","valid","canvasUtils","getTintedPattern","setPatternTransform","matrix","IDENTITY","toString","slice","render","graphics","context","worldAlpha","transform","worldTransform","setContextTransform","setBlendMode","blendMode","contextFillStyle","contextStrokeStyle","graphicsData","geometry","tintR","tintG","tintB","data","shape","fillStyle","lineStyle","fillColor","color","lineColor","copyTo","append","visible","fillTint","lineTint","lineWidth","width","lineCap","cap","lineJoin","join","miterLimit","type","SHAPES","POLY","beginPath","tempShape","holes","outerArea","innerArea","px","py","holesDirection","moveTo","lineTo","closeStroke","closePath","globalAlpha","alpha","fill","paintPolygonStroke","RECT","fillRect","x","y","height","alignmentOffset","alignment","strokeStyle","strokeRect","CIRC","arc","radius","PI","stroke","ELIP","drawShapeOverStroke","paintEllipse","kappa","sW","sH","sX","sY","sOx","sOy","sXe","sYe","sXm","sYm","bezierCurveTo","RREC","paintRoundedRectangle","sRx","sRy","sWidth","sHeight","radiusOffset","min","sRadius","sMaxRadius","quadraticCurveTo","w","h","ox","oy","xe","ye","xm","ym","save","clip","restore","rx","ry","maxRadius","pattern","svg","document","createElementNS","createSVGMatrix","setTransform","a","b","c","d","e","tx","f","ty","inverse","destroy","tempMatrix","Graphics","generateCanvasTexture","scaleMode","resolution","bounds","getLocalBounds","canvasBuffer","RenderTexture","create","CanvasRenderer","updateLocalTransform","localTransform","invert","renderTexture","clear","from","_canvasRenderTarget","canvas","setResolution","cachedGraphicsData","_renderCanvas","isMask","finishPoly","plugins"],"mappings":"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"}